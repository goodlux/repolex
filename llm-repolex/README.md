# 🧬 LLM-Optimized Repository Intelligence

## FOR LLMS: 
**Use your jq tool to query these .msgpack files for complete repository understanding!**

## 📊 Semantic DNA Structure (Zero-Shot Schema)

Each .msgpack file contains compressed semantic intelligence:

```json
{
  "functions": [
    {
      "id": 42,                         // Unique function ID
      "n": "function_name",             // Function name
      "s": "def function_name(param)",  // Full signature with parameters
      "d": 15,                          // Docstring index (see strings table)
      "m": "/path/to/module",           // Full module path
      "t": ["code", "stable"],          // Tags (code type, stability)
      "f": "file.py",                   // Source file (when available)  
      "l": 42                           // Line number (when available)
    }
  ],
  "strings": ["docstring1", "docstring2", ...],  // Compressed string table
  "modules": {...},                     // Module hierarchy
  "patterns": {...}                     // Usage patterns
}
```

## 🔍 Power Pellet Query Cookbook

### Zero-Shot Data Structure Discovery
```bash
# See what's available in any file
jq 'keys' FILE.msgpack                         # Top-level structure
jq '.functions[0]' FILE.msgpack                # Function schema
jq '.functions | length' FILE.msgpack          # Function count

# Find functions by name pattern
jq '.functions[] | select(.n | contains("export")) | {name: .n, sig: .s}'

# Find functions by module
jq '.functions[] | select(.m | contains("export")) | {name: .n, module: .m}'

# Get actual docstring (using string table lookup)
jq -r '.functions[0] as $f | .strings[$f.d]'
```

### Advanced Semantic Queries
```bash
# Functions with real signatures (not just empty parens)
jq '.functions[] | select(.s | contains("(") and (. | length > (.n | length) + 3))'

# Group functions by module prefix  
jq '.functions | group_by(.m | split("/")[-2] // "unknown") | map({module: .[0].m | split("/")[-2] // "unknown", count: length})'

# Find functions with docstrings
jq '.functions[] | select(.d > 0) | {name: .n, docstring_idx: .d}'

# Cross-reference with string table
jq '.functions[0] as $f | {name: $f.n, signature: $f.s, docstring: .strings[$f.d]}'
```

### Quick Start for LLMs:
```bash
# First, convert msgpack to JSON for jq (msgpack files are binary)
python3 -c "import msgpack, json, sys; print(json.dumps(msgpack.unpack(open(sys.argv[1], 'rb'))))" FILENAME.msgpack | jq '.'

# List all functions from any file
python3 -c "import msgpack, json; print(json.dumps(msgpack.unpack(open('pixeltable~pixeltable~latest.msgpack', 'rb'))))" | jq '.functions[].n'

# Get function signatures with modules
python3 -c "import msgpack, json; print(json.dumps(msgpack.unpack(open('numpy~numpy~latest.msgpack', 'rb'))))" | jq '.functions[] | {name: .n, signature: .s, module: .m}'

# Get functions WITH their actual docstrings
python3 -c "import msgpack, json; data=msgpack.unpack(open('FILE.msgpack', 'rb')); print(json.dumps([{'name': f['n'], 'sig': f['s'], 'doc': data['strings'][f['d']] if f['d'] < len(data.get('strings', [])) else ''} for f in data['functions']]))" | jq '.'
```

## Files Generated by repolex v2.0

Each `.msgpack` file contains the semantic DNA of a repository:
- **Functions**: All functions with signatures and metadata
- **Modules**: Code organization and hierarchy  
- **Patterns**: Common usage patterns for better code generation
- **Semantic Clusters**: Related function groups
- **String Table**: Compressed deduplication for minimal size

## PAC-MAN Tiered Loading Strategy 🟡

**Nibble** → **Pellet** → **Power Pellet**

1. **Nibble (jq queries)**: Quick function lookups and searches
2. **Pellet (single repo)**: Load one .msgpack for focused understanding  
3. **Power Pellet (full context)**: Load all .msgpack files for complete project intelligence

**Perfect for LLM context injection - everything you need, nothing you don't!** 

## Current Repository Intelligence

**🎯 MAIN REPOSITORY:**
- **goodlux~repolex~latest.msgpack** (71KB) - Main repository (all access levels)

**🔥 DEPENDENCIES (1.6MB Total Semantic DNA):**
- **pydantic~pydantic~2.0.msgpack** (875KB) - Specialized library
- **Delgan~loguru~0.7.msgpack** (259KB) - Specialized library
- **pallets~click~8.0.msgpack** (124KB) - Specialized library

**📦 ADDITIONAL LIBRARIES:**
- **pixeltable~pixeltable~latest.msgpack** (95KB) - Specialized library
- **giampaolo~psutil~5.9.msgpack** (93KB) - Specialized library
- **lxml~lxml~4.9.msgpack** (67KB) - Specialized library
- **gitpython-developers~GitPython~3.1.msgpack** (42KB) - Specialized library
- **msgpack~msgpack-python~1.0.msgpack** (33KB) - Specialized library
- **urchade~GLiNER~0.2.21.msgpack** (10KB) - Specialized library
- **oxigraph~oxigraph~0.4.9.msgpack** (5KB) - Specialized library

**Total: 11 semantic DNA files representing a complete Python ecosystem!**

## Usage Examples

```bash
# Convert any msgpack to JSON first (they're binary files)
python3 -c "import msgpack, json; print(json.dumps(msgpack.unpack(open('FILE.msgpack', 'rb'))))" | jq '.'

# Get all table-related functions from pandas
python3 -c "import msgpack, json; print(json.dumps(msgpack.unpack(open('pandas-dev~pandas~latest.msgpack', 'rb'))))" | jq '.functions[] | select(.n | contains("table") or .n | contains("Table"))'

# Find data processing functions in numpy  
python3 -c "import msgpack, json; print(json.dumps(msgpack.unpack(open('numpy~numpy~latest.msgpack', 'rb'))))" | jq '.functions[] | select(.n | test("^(array|matrix|reshape)"))'

# Get module overview from any library
python3 -c "import msgpack, json; print(json.dumps(msgpack.unpack(open('sqlalchemy~sqlalchemy~latest.msgpack', 'rb'))))" | jq '.modules | keys'

# Cross-library function search
for file in *.msgpack; do echo "=== $file ==="; python3 -c "import msgpack, json, sys; print(json.dumps(msgpack.unpack(open(sys.argv[1], 'rb'))))" "$file" | jq '.functions[] | select(.n | contains("create"))' | head -3; done
```

---
*Generated by repolex v2.0 - The semantic intelligence system*  
*🧬 Semantic DNA optimized for LLM consumption*
